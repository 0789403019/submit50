#!/usr/bin/env python

import argparse
import atexit
import datetime
import distutils
import itertools
import json
import os
import pexpect
import pipes
import re
import requests
import select
import shlex
import shutil
import signal
import subprocess
import sys
import termcolor
import tempfile
import textwrap
import time
import traceback

from backports.shutil_get_terminal_size import get_terminal_size
from backports.shutil_which import which
from distutils.spawn import find_executable
from distutils.version import StrictVersion
from pkg_resources import get_distribution, parse_version
from six.moves import urllib
from threading import Thread

# require python 2.7+
if sys.version_info < (2, 7):
    sys.exit("You have an old version of python. Install version 2.7 or higher.")
if sys.version_info < (3, 0):
    input = raw_input
if not hasattr(shlex, "quote"):
    shlex.quote = pipes.quote

ORG = "submit50"
__version__ = get_distribution("submit50").version
timestamp = ""


class Error(Exception):
    """Exception raised for errors."""
    pass


# submit50
def main():

    # listen for ctrl-c
    signal.signal(signal.SIGINT, handler)

    # clean up on normal exit
    atexit.register(teardown)

    # start spinner
    spin("Connecting")

    # check version
    res = requests.get("https://cs50.me/versions/submit50")
    if res.status_code != 200:
        raise Error("You have an unknown version of submit50. " +
                    "Email sysadmins@cs50.harvard.edu!")
    version_required = res.text.strip()
    if parse_version(version_required) > parse_version(__version__):
        raise Error("You have an old version of submit50. " +
                    "Run update50, then re-run submit50!")

    # compute timestamp
    headers = requests.get("https://api.github.com/").headers
    global timestamp
    timestamp = datetime.datetime.strptime(headers["Date"], "%a, %d %b %Y %H:%M:%S %Z")
    timestamp = timestamp.strftime("%Y%m%dT%H%M%SZ")

    # check for git 2.7+, so that credential-cache--daemon ignores SIGHUP
    # https://github.com/git/git/blob/v2.7.0/credential-cache--daemon.c
    if not which("git"):
        raise Error("You don't have git. Install git, then re-run submit50!.")
    version = run("git --version")
    matches = re.search(r"^git version (\d+\.\d+\.\d+)$", version)
    if not matches or StrictVersion(matches.group(1)) < StrictVersion("2.7.0"):
        raise Error("You have an old version of git. Install version 2.7 or later, then re-run submit50!")

    # define command-line arguments
    parser = argparse.ArgumentParser(prog="submit50")
    parser.add_argument("-v", "--verbose",
                        action="store_true",
                        help="show commands being executed")
    parser.add_argument("problem", help="problem to submit")
    args = vars(parser.parse_args())

    # submit50 -v
    # submit50 --verbose
    if args["verbose"]:
        run.verbose = True

    # submit50 problem
    submit(args["problem"])

    # kthxbai
    sys.exit(0)


def authenticate():
    """Authenticate user."""

    # cache credentials in ~/.git-credential-cache/submit50
    cache = os.path.expanduser("~/.git-credential-cache")
    try:
        os.mkdir(cache, 0o700)
    except:
        pass
    socket = os.path.join(cache, ORG)

    # check cache for credentials
    credentials = run("git -c credential.helper='cache --socket {}' credential fill".format(socket),
                      lines=[""]*3,
                      quiet=True)
    run("git credential-cache --socket {} exit".format(socket))

    # prompt for username if not in cache
    matches = re.search("^username=([^\r]+)\r?$", credentials, re.MULTILINE)
    if matches:
        username = matches.group(1)
    else:
        while True:
            cprint("GitHub username:", end=" ", flush=True)
            username = input().strip()
            if username:
                break

    # prompt for password if not in cache
    matches = re.search("^password=([^\r]+)\r?$", credentials, re.MULTILINE)
    if matches:
        password = matches.group(1)
    else:
        while True:
            cprint("GitHub password:", end=" ", flush=True)
            password = str()
            while True:
                ch = getch()
                if ch in ["\n", "\r"]: # Enter
                    cprint()
                    break
                elif ch == "\177": # DEL
                    if len(password) > 0:
                        password = password[:-1]
                        cprint("\b \b", end="", flush=True)
                elif ch == "\3": # ctl-c
                    cprint("^C")
                    os.kill(os.getpid(), signal.SIGINT)
                else:
                    password += ch
                    cprint("*", end="", flush=True)
            if password:
                break

    # authenticate user
    email = "{}@users.noreply.github.com".format(username)
    res = requests.get("https://api.github.com/user",
                       auth=(username, password))

    # check for 2-factor authentication
    # http://github3.readthedocs.io/en/develop/examples/oauth.html?highlight=token
    if "X-GitHub-OTP" in res.headers:
        password = two_factor(username, password)
        res = requests.get("https://api.github.com/user",
                           auth=(username, password))

    # check if incorrect password
    if res.status_code == 401:
        raise Error("Invalid username and/or password.")

    # check for other error
    elif res.status_code != 200:
        raise Error("Could not authenticate user.")

    # canonicalize (capitalization of) username,
    # especially if user logged in via email address
    username = res.json()["login"]

    # cache credentials for 1 week
    timeout = int(datetime.timedelta(weeks=1).total_seconds())
    run("git -c credential.helper='cache --socket {} --timeout {}' "
        "-c credentialcache.ignoresighup=true credential approve".format(socket, timeout),
        lines=["username={}".format(username), "password={}".format(password), "", ""],
        quiet=True)

    # return credentials
    return (username, password, email)


def cprint(text="", color=None, on_color=None, attrs=None, **kwargs):
    """Colorizes text (and wraps to terminal's width)."""

    # stop spinner (if spinning)
    spin(False)

    # assume 80 in case not running in a terminal
    columns, _ = get_terminal_size((80, 0))

    # only python3 supports "flush" keyword argument
    if sys.version_info < (3, 0) and "flush" in kwargs:
        del kwargs["flush"]

    # print text
    termcolor.cprint(textwrap.fill(text, columns),
                     attrs=attrs, color=color, on_color=on_color, **kwargs)


def excepthook(type, value, tb):
    """Report an exception."""
    excepthook.ignore = False
    spin(False)
    teardown()
    if type is Error and str(value):
        cprint(str(value), "yellow")
    else:
        if run.verbose:
            traceback.print_exception(type, value, tb)
        traceback.print_exception(type, value, tb)
        cprint("Sorry, something's wrong! Let sysadmins@cs50.harvard.edu know!", "yellow")
    cprint("Submission cancelled.", "red")
sys.excepthook = excepthook


def handler(number, frame):
    """Handle SIGINT."""
    spin(False)
    print()
    cprint("Submission cancelled.", "red")
    os._exit(0)
    
def run(command, cwd=None, env=None, lines=[], password=None, quiet=False):
    """Run a command."""

    # echo command
    if run.verbose:
        cprint(command)

    # include GIT_DIR and GIT_WORK_TREE in env
    if not env:
        env = {
            "GIT_DIR": run.GIT_DIR,
            "GIT_WORK_TREE": run.GIT_WORK_TREE,
            "HOME": os.environ.get("HOME") or os.path.expanduser("~")
        }

    # spawn command
    if sys.version_info < (3, 0):
        child = pexpect.spawn(command, cwd=cwd, env=env, ignore_sighup=True, timeout=None)
    else:
        child = pexpect.spawnu(command, cwd=cwd, encoding="utf-8", env=env, ignore_sighup=True, timeout=None)

    # send output of command to stdout only if run with --verbose (and not quieted by caller)
    if run.verbose and not quiet:
        child.logfile_read = sys.stdout

    # wait for prompt, send password
    if password:
        res = child.expect(["Password for '.*': ", pexpect.EOF])
        if res == 0:
            child.sendline(password)

    # send lines of input
    for line in lines:
        child.sendline(line)

    # read output, check status
    command_output = child.read().strip()
    child.close()
    if child.signalstatus is None and child.exitstatus != 0:
        raise Error()
    return command_output


run.GIT_DIR = tempfile.mkdtemp()
run.GIT_WORK_TREE = os.getcwd()
run.verbose = False


def spin(message):
    """Displays a spinning message."""

    # don't spin in verbose mode
    if run.verbose:
        return

    # stop spinning if already spinning
    if spin.spinning:
        spin.spinning = False
        spin.thread.join()

    # start spinning if message passed
    if message:
        def spin_helper():
            spinner = itertools.cycle(["-", "\\", "|", "/"])
            sys.stdout.write(message + "... ")
            sys.stdout.flush()
            while spin.spinning:
                sys.stdout.write(next(spinner))
                sys.stdout.flush()
                sys.stdout.write("\b")
                time.sleep(0.1)
            sys.stdout.write("\033[2K\r")
            sys.stdout.flush()
        spin.spinning = True
        spin.thread = Thread(target=spin_helper)
        spin.thread.start()


spin.spinning = False


def submit(problem):
    """Submit problem."""

    # update spinner
    spin("Preparing")

    # assume cs50/ problem if problem name begins with a year
    branch = problem
    if problem.split("/")[0].isdigit():
        branch = os.path.join("cs50", problem)

    # ensure problem exists
    _, submit.EXCLUDE = tempfile.mkstemp()
    url = "https://cs50.me/excludes/{}/".format(branch)
    try:
        urllib.request.urlretrieve(url, filename=submit.EXCLUDE)
        lines = open(submit.EXCLUDE)
    except Exception as e:
        if run.verbose:
            cprint(str(e))
        e = Error("Invalid problem. Did you mean to submit something else?")
        e.__cause__ = None
        raise e

    # check for missing files
    missing = []
    for line in lines:
        matches = re.match(r"^\s*#\s*([^\s]+)\s*$", line)
        if matches:
            pattern = matches.group(1)
            if pattern[:-1] == "/":
                if not os.path.isdir(pattern):
                    missing.append(pattern)
            elif not os.path.isfile(pattern):
                missing.append(pattern)
    if missing:
        cprint("You seem to be missing these files:")
        for pattern in missing:
            cprint(" {}".format(pattern))
        raise Error("Ensure you have the required files before submitting.")

    # authenticate user
    username, password, email = authenticate()

    # update spinner
    spin("Authenticating")

    # check for submit50 repository
    res = requests.get("https://api.github.com/repos/{}/{}".format(ORG, username), auth=(username, password))
    if res.status_code != 200:
        raise Error("Looks like submit50 isn't enabled for your account yet. Log into https://cs50.me/ in a browser, click \"Authorize application\", then re-run submit50 here!")

    # update spinner
    spin("Preparing")

    # clone submit50 repository
    repo = "https://{}@github.com/{}/{}".format(username, ORG, username)
    run("git clone --bare {} {}".format(
        shlex.quote("https://{}@github.com/{}/{}".format(username, ORG, username)), shlex.quote(run.GIT_DIR)),
        password=password)

    # set options
    tag = "{}@{}".format(branch, timestamp)
    run("git config user.email {}".format(shlex.quote(email)))
    run("git config user.name {}".format(shlex.quote(username)))
    run("git symbolic-ref HEAD refs/heads/{}".format(shlex.quote(branch)))

    # patterns of file names to exclude
    run("git config core.excludesFile {}".format(shlex.quote(submit.EXCLUDE)))

    # adds, modifies, and removes index entries to match the working tree
    run("git add --all")

    # get file lists
    files = run("git ls-files").split()
    other = run("git ls-files --other").split()

    # files that will be submitted
    if len(files) == 0:
        raise Error("No files in this directory are expected for submission.")
    cprint("Files that will be submitted:", "yellow")
    for f in files:
        cprint("./{}".format(f), "yellow")

    # files that won't be submitted
    if len(other) != 0:
        cprint("Files that won't be submitted:", "yellow")
        for f in other:
            cprint("./{}".format(f), "yellow")

    # prompt for academic honesty
    cprint("Keeping in mind the course's policy on academic honesty, " +
           "are you sure you want to submit these files?", end=" ")
    if not re.match("^\s*(?:y|yes)\s*$", input(), re.I):
        raise Error("No files were submitted.")

    # restart spinner
    spin("Submitting")

    # push branch
    run("git commit --allow-empty --message='{}'".format(timestamp))
    run("git push origin 'refs/heads/{}'".format(branch), password=password)

    # push tag
    # http://stackoverflow.com/a/23486788
    hash = run("git commit-tree HEAD^{{tree}} -m '{}'".format(timestamp))
    hash = hash.strip()
    run("git push origin {}:refs/tags/{}".format(hash, tag), password=password)

    # successful submission
    cprint("Submitted {}! ".format(problem) +
           "See https://cs50.me/submissions/{}.".format(branch),
           "green")


submit.EXCLUDE = None


def teardown():
    """Delete temporary directory and temporary file."""
    shutil.rmtree(run.GIT_DIR, ignore_errors=True)
    if submit.EXCLUDE:
        try:
            os.remove(submit.EXCLUDE)
        except Exception:
            pass


def two_factor(username, password):
    """Get one-time authentication code."""
    # send authentication request
    requests.post("https://api.github.com/authorizations",
                  auth=(username, password))
    while True:
        cprint("Authentication code:", end=" ", flush=True)
        code = input()
        if code:
            break
    data = json.dumps({"scopes": ["repo", "user"], "note": "{} {}".format(ORG, timestamp)})
    res = requests.post("https://api.github.com/authorizations",
                        auth=(username, password),
                        data=data,
                        headers={"X-GitHub-OTP": str(code)})
    if res.status_code == 201 and "token" in res.json():
        return res.json()["token"]
    else:
        raise Error("Could not complete two-factor authentication.")


# https://stackoverflow.com/a/510364
class _Getch:
    """Gets a single character from standard input."""

    class _GetchUnix:
        def __init__(self):
            import tty, sys

        def __call__(self):
            import sys, termios, tty
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                tty.setraw(sys.stdin.fileno())
                ch = sys.stdin.read(1)
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            return ch

    class _GetchWindows:
        def __init__(self):
            import msvcrt

        def __call__(self):
            import msvcrt
            return msvcrt.getch()

    def __init__(self):
        try:
            self.impl = _Getch._GetchWindows()
        except ImportError:
            self.impl = _Getch._GetchUnix()

    def __call__(self):
        return self.impl()


getch = _Getch()

if __name__ == "__main__":
    main()
